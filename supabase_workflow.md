# Supabase Workflow for This Project

This document outlines how Supabase is integrated into this project, covering local development, database migrations, authentication, data access, Row Level Security (RLS), and other relevant Supabase features.

## 1. Overview

Supabase is an open-source Firebase alternative that provides a suite of tools to build applications quickly. In this project, it serves as the backend, offering:

- A PostgreSQL database.
- Authentication.
- Auto-generated APIs.
- Edge Functions.
- Storage (if used).

The goal is to manage backend schema, security, and logic in a structured and version-controlled way.

## 2. Project Structure for Supabase

Key files and directories related to Supabase integration:

- `supabase/`: This directory is the heart of the Supabase local development setup.
  - `config.toml`: Contains the Supabase project ID and other local configuration. **Do not commit sensitive keys to this file if they were ever to be added, though typically it only stores the project ID.**
  - `migrations/`: Stores all database schema changes as SQL files. Each file represents a step in the evolution of your database schema.
  - `functions/`: Contains code for Supabase Edge Functions (e.g., `paddle-webhook` in this project).
- `src/integrations/supabase/client.ts`: Initializes the Supabase JavaScript client, which is used by the frontend application to interact with your Supabase backend.
- `src/integrations/supabase/types.ts`: Contains TypeScript type definitions for your database schema, likely generated by Supabase.

## 3. Supabase CLI

The Supabase Command Line Interface (CLI) is essential for managing your Supabase project, especially for local development and migrations.

**Installation/Usage:**

It's recommended to use `npx` to ensure you're always using a version compatible with your Supabase project, or you can install it globally.

- Using with `npx`: `npx supabase <command>`
- Global install (if preferred): `npm install -g supabase` then `supabase <command>`

**Common CLI Commands:**

- `supabase login`: Authenticate the CLI with your Supabase account (required once).
- `supabase link --project-ref <your-project-ref>`: Links your local Supabase project setup to your actual Supabase project in the cloud. The `<your-project-ref>` can be found in your Supabase project's dashboard URL (e.g., ``for this project, as seen in`config.toml`). This is crucial for pushing migrations.
- `supabase start`: Starts the local Supabase stack (PostgreSQL, Kong, GoTrue, Realtime, Storage, Functions) using Docker. Your frontend should connect to the local Supabase URLs/ports when this is running.
- `supabase stop`: Stops the local Supabase stack.
- `supabase db reset`: Resets your local database to the latest schema by applying all migrations from the `supabase/migrations` folder. **Caution: This erases all data in your local database.**
- `supabase functions deploy <function_name>`: Deploys a specific Edge Function to your linked Supabase project. Use `supabase functions deploy --project-ref <your-project-ref> <function_name>` if not linked or to specify.
- `supabase functions serve --no-verify-jwt <function_name>`: Serves a specific Edge Function locally for testing. `--no-verify-jwt` is often useful for local testing to bypass JWT verification.

## 4. Database Migrations

Migrations are SQL files that define incremental changes to your database schema. They are critical for:

- **Version Control:** Tracking schema changes alongside your codebase.
- **Collaboration:** Ensuring all team members have the same database structure.
- **Reproducibility:** Reliably setting up or modifying the database schema in different environments (local, staging, production).

**Workflow:**

1.  **Ensure your local Supabase stack is running:** `supabase start`
2.  **Create a new migration file:**
    ```bash
    npx supabase migration new <descriptive_migration_name>
    # Example: npx supabase migration new create_orders_table
    ```
    This creates a new SQL file in the `supabase/migrations/` directory with a timestamped name.
3.  **Edit the migration file:** Add your SQL statements (e.g., `CREATE TABLE`, `ALTER TABLE`, `CREATE POLICY`) to this file. The project's existing migration `20250705084351-36e3965e-b16a-4092-b1f4-d78eaf9e9dd5.sql` is a great example of table creation, RLS policy setup, triggers, and seeding data.
4.  **Apply migrations locally:**
    - To apply all migrations and reset the local database (common during development): `npx supabase db reset`
    - (Alternatively, to apply new migrations without a full reset, though less common with the CLI's typical local dev flow: `supabase migration up`. This is more for production-like environments).
5.  **Test your changes locally.**
6.  **Push migrations to your remote Supabase project (staging/production):**
    ```bash
    npx supabase db push --project-ref <your-project-ref>
    ```
    This command applies any migrations from your local `supabase/migrations` folder that have not yet been applied to your linked remote Supabase database. This is typically done as part of a CI/CD pipeline for staging/production environments after changes are merged to the main branch.

## 5. Authentication

Supabase provides a complete authentication solution.

- **Client-Side Integration:** The frontend uses the Supabase client (`src/integrations/supabase/client.ts`) to interact with Supabase Auth. Common functions include:
  - `supabase.auth.signUp({ email, password })`
  - `supabase.auth.signInWithPassword({ email, password })`
  - `supabase.auth.signOut()`
  - `supabase.auth.onAuthStateChange(...)` to listen for login/logout events.
  - These are often abstracted in custom hooks (e.g., `src/hooks/useAuth.tsx`).
- **`auth.users` Table:** Supabase automatically manages an `auth.users` table to store user information.
- **Automatic Profile Creation:** As seen in the migration `20250705084351-36e3965e-b16a-4092-b1f4-d78eaf9e9dd5.sql`, this project uses a trigger (`on_auth_user_created`) and a function (`handle_new_user`) to automatically create a corresponding public profile in the `public.profiles` table when a new user signs up in `auth.users`. This is a common and recommended pattern.

## 6. Data Access & Row Level Security (RLS)

**Data Access:**

The application frontend queries and mutates data using the Supabase client:

```typescript
// Example: Fetching data
const { data, error } = await supabase.from("your_table_name").select("*");

// Example: Inserting data
const { data, error } = await supabase
  .from("your_table_name")
  .insert([{ column1: "value1", column2: "value2" }]);
```

**Row Level Security (RLS):**

RLS is a PostgreSQL feature that Supabase leverages to provide fine-grained control over data access. It allows you to define policies that determine which rows users can access or modify in a table.

- **Importance:** RLS is **CRITICAL** for security. Without it, users might be able to access or modify data they shouldn't. By default, RLS is disabled on new tables, and you must enable it and create policies.
- **Defining Policies:** Policies are SQL statements. In this project, they are correctly defined within the migration files (e.g., for `profiles`, `subscription_plans`, `user_subscriptions`, `saved_text_settings` tables).

  - Example from `20250705084351-36e3965e-b16a-4092-b1f4-d78eaf9e9dd5.sql`:

    ```sql
    -- Enable RLS for the table
    ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

    -- Policy: Users can view their own profile
    CREATE POLICY "Users can view their own profile" ON public.profiles
      FOR SELECT USING (auth.uid() = user_id);

    -- Policy: Users can update their own profile
    CREATE POLICY "Users can update their own profile" ON public.profiles
      FOR UPDATE USING (auth.uid() = user_id);
    ```

- **Editing Policies:**

  1.  **Recommended Method (Version Controlled):**

      - Modify the existing SQL policy definitions within the relevant migration file if the migration hasn't been applied to all environments yet.
      - Or, create a **new migration file** to `ALTER` or `DROP` and `CREATE` policies. This keeps changes version controlled.

        ```bash
        npx supabase migration new update_profile_policies
        ```

        Then in the new SQL file:

        ```sql
        -- Example: Drop an old policy
        DROP POLICY "Users can view their own profile" ON public.profiles;

        -- Example: Create an updated or new policy
        CREATE POLICY "Users can view their own profile and admins can view all" ON public.profiles
          FOR SELECT USING (auth.uid() = user_id OR auth.role() = 'service_role'); -- Adjust logic as needed
        ```

      - Apply the migration locally (`supabase db reset` or `supabase migration up`) and then push to remote (`supabase db push`).

  2.  **Supabase Dashboard (GUI):**
      - You can view and edit RLS policies directly in the Supabase Dashboard under "Authentication" -> "Policies" or by navigating to a table in the "Table Editor" and clicking "Row Level Security".
      - **Use with Caution:** While convenient for quick checks or temporary adjustments, changes made via the dashboard are **not version controlled** with your codebase. It's easy for these changes to be overwritten by subsequent migration deployments or become out of sync.
      - If you make changes via the dashboard that you want to keep, you should then script them out into a new migration file to ensure they are part of your project's history. Supabase Dashboard often provides the SQL for the policies you create via the UI, which you can copy.

## 7. Edge Functions

Supabase Edge Functions are serverless functions that run geographically close to your users.

- **Location:** Code for Edge Functions resides in the `supabase/functions/` directory. Each subdirectory typically represents a single function.
- **Example:** This project has a `paddle-webhook` function in `supabase/functions/paddle-webhook/index.ts`.
- **Deployment:**
  ```bash
  npx supabase functions deploy <function_name> --project-ref <your-project-ref>
  # Example: npx supabase functions deploy paddle-webhook --project-ref ummxlnjjrnwqvuxpkdfc
  ```
- **Local Testing:**
  ```bash
  npx supabase functions serve --no-verify-jwt <function_name>
  # Example: npx supabase functions serve --no-verify-jwt paddle-webhook
  ```

## 8. Supabase Storage

Supabase provides S3-compatible object storage for files like images, videos, and other assets.

- While not explicitly detailed in the explored files, if the project needs to store user-generated content (e.g., avatars from `profiles.avatar_url`), Supabase Storage is the integrated solution.
- Access to storage buckets is also controlled by RLS-like policies defined via SQL or the Supabase Dashboard.

## 9. Local Development Workflow Summary

1.  **Start Supabase services:** `npx supabase start`
2.  **Run your frontend development server:** (e.g., `npm run dev`). The frontend should be configured to connect to the local Supabase instance (check `.env` or configuration files for URLs like `http://localhost:54321` for Supabase services).
3.  **Make code changes:**
    - For **database schema changes** (tables, columns, policies):
      1.  Create a new migration: `npx supabase migration new <migration_name>`
      2.  Edit the SQL file in `supabase/migrations/`.
      3.  Apply and test: `npx supabase db reset` (this will re-apply all migrations).
    - For **Edge Function changes**:
      1.  Edit the function code in `supabase/functions/`.
      2.  Test locally: `npx supabase functions serve --no-verify-jwt <function_name>`
4.  **Commit changes** to Git (including new migration files and function code).
5.  **Stop Supabase services:** `npx supabase stop` when done.

## 10. Deployment to Staging/Production

- **Schema Migrations:** Typically handled by a CI/CD pipeline. When code is merged to `main` or a `staging` branch, the pipeline should run `npx supabase db push --project-ref <your-project-ref>`.
- **Edge Functions:** Also typically deployed via CI/CD: `npx supabase functions deploy <function_name> --project-ref <your-project-ref>`.
- Ensure your live application is configured with the correct Supabase Project URL and `anon` key for the respective environment.

This workflow ensures that your Supabase backend evolves in a controlled, testable, and reproducible manner alongside your application code.
